%{
    #include <assert.h>
    #include <iostream>

    #include "nodes/visitor.h" // includes all nodes 
    //             (might change later, this is kind of a hack)
    //             (some of the headers arent even used)

    #include "scanner.c"
    
    using namespace std;
    extern "C" int yylex(void);
    extern int yylineno;

    void yyerror(const char *s) {
        cerr << "Error (line " << yylineno << "): " << s << endl;
    }
    ProgramNode *program;
%}

%union{
  int intVal;
  float floatVal;
  char *idName;
  class Node *node;
  class ExpNode *expNode;
  class StatementNode *statementNode;
  std::vector<class StatementNode*> *statementList;
}

%start program

%token <intVal> INTEGER_LITERAL
%token <floatVal> FLOAT_LITERAL
%token <intVal> CHAR_LITERAL
%token <idName> ID
%token <idName> STRING_LITERAL
%token SEMI
%token COMMA
%token ASSIGN
%token ARRAY_START     // [
%token ARRAY_END       // ]
%token PAREN_LEFT      // (
%token PAREN_RIGHT     // )
%token BRACE_LEFT      // (
%token BRACE_RIGHT     // )
%token DEFINE_DEFAULT  // :

%token PRINT
%token OPEN READ WRITE CLOSE

%token IF

//     <= >= == !=  <  >
%token LE GE EQ NE LT GT

%type <expNode> exp
%type <statementNode> statement
%type <statementList> block
%type <statementList> statements
%type <node> program
%left   PLUS MINUS
%left   MULT DIV
%left   LE GE EQ NE LT GT  // <-- NEW PRECEDENCE LEVEL
// %prec  UMINUS

//always define most specific first, least specific last in statements
%%
program: { program = new ProgramNode(yylineno); }
    | program statement { assert(program); program->addStatement($2); }
    ;

block: BRACE_LEFT BRACE_RIGHT { $$ = new std::vector<StatementNode*>(); }
     | BRACE_LEFT statements BRACE_RIGHT { $$ = $2; }
;

statements: statement { 
                // First statement creates a new vector containing itself
                $$ = new std::vector<StatementNode*>(); 
                $$->push_back($1); 
                  std::cout << "STATEMENT 1st part" <<  std::endl;
            }
    | statements statement { 
                // Subsequent statements push onto the existing vector
                $1->push_back($2); 
                $$ = $1; 
                  std::cout << "STATENENT 2nd part" <<  std::endl;
            }
;


statement: 
      ID ARRAY_START exp ARRAY_END DEFINE_DEFAULT exp SEMI { $$ = new ArrayDefNode(yylineno, strdup($1), $3, $6); free($1); } 
    | ID ARRAY_START exp ARRAY_END ASSIGN exp SEMI 
      { 
          $$ = new ArrayAssignNode(yylineno, strdup($1), $3, $6); 
          free($1); 
      }
    | ID ASSIGN exp SEMI { $$ = new AssignmentNode(yylineno, strdup($1), $3); free($1);}
    | exp SEMI { $$ = new StatementNode(yylineno, $1); }
    
    | IF PAREN_LEFT exp PAREN_RIGHT block 
      { $$ = new IfNode(yylineno, $3, $5);   std::cout << "IF" <<  std::endl;}
    | PRINT PAREN_LEFT exp PAREN_RIGHT SEMI { $$ = new PrintNode(yylineno,$3);  std::cout << "PRINT" <<  std::endl;}
    ;

exp:
    OPEN PAREN_LEFT exp COMMA exp COMMA exp PAREN_RIGHT { $$ = new OpenNode(yylineno,$3,$5,$7);  std::cout << "OPEN" << std::endl;}
    | READ PAREN_LEFT exp COMMA exp COMMA exp PAREN_RIGHT { $$ = new ReadNode(yylineno,$3,$5,$7);  std::cout << "READ" << std::endl;}
    | WRITE PAREN_LEFT exp COMMA exp COMMA exp PAREN_RIGHT { $$ = new WriteNode(yylineno,$3,$5,$7);  std::cout << "WRITE" << std::endl;}
    | CLOSE PAREN_LEFT exp PAREN_RIGHT { $$ = new CloseNode(yylineno,$3);  std::cout << "CLOSE" << std::endl;}

    | INTEGER_LITERAL  { $$ = new IntegerNode(yylineno, $1);}
    | FLOAT_LITERAL { $$ = new FloatNode(yylineno, $1); }
    | CHAR_LITERAL  { $$ = new CharNode(yylineno, $1);}
    | STRING_LITERAL{ $$ = new StringNode(yylineno, strdup($1)); free($1);}
    | ID            { $$ = new IdentifierNode(yylineno, strdup($1)); free($1); }
    | PAREN_LEFT exp PAREN_RIGHT { $$ = $2; }
    | MINUS exp { $$ = new UMinusNode(yylineno, $2); }
    | exp PLUS exp  { $$ = new PlusNode(yylineno, $1, $3); }
    | exp MINUS exp { $$ = new MinusNode(yylineno, $1, $3); }
    | exp MULT exp  { $$ = new MultNode(yylineno, $1, $3); }
    | exp DIV exp   { $$ = new DivNode(yylineno, $1, $3); }
    | ID ARRAY_START exp ARRAY_END { $$ = new ArrayAccessNode(yylineno, strdup($1), $3); free($1); }
    
    | exp LT exp  { $$ = new ComparisonNode(yylineno, $1, $3, ComparisonNode::OpType::LT); }
    | exp GT exp  { $$ = new ComparisonNode(yylineno, $1, $3, ComparisonNode::OpType::GT); }
    | exp LE exp  { $$ = new ComparisonNode(yylineno, $1, $3, ComparisonNode::OpType::LE); }
    | exp GE exp  { $$ = new ComparisonNode(yylineno, $1, $3, ComparisonNode::OpType::GE); }
    | exp EQ exp  { $$ = new ComparisonNode(yylineno, $1, $3, ComparisonNode::OpType::EQ); }
    | exp NE exp  { $$ = new ComparisonNode(yylineno, $1, $3, ComparisonNode::OpType::NE); }
    ;
