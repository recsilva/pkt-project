%{
    #include <assert.h>
    #include <iostream>

    #include "nodes/visitor.h" // includes all nodes 
    //             (might change later, this is kind of a hack)
    //             (some of the headers arent even used)

    #include "scanner.c"
    
    using namespace std;
    extern "C" int yylex(void);
    extern int yylineno;

    void yyerror(const char *s) {
        cerr << "Error (line " << yylineno << "): " << s << endl;
    }
    ProgramNode *program;
%}

%union{
  int intVal;
  float floatVal;
  char *idName;
  class Node *node;
  class ExpNode *expNode;
  class StatementNode *statementNode;
}

%start program

%token <intVal> INTEGER_LITERAL
%token <floatVal> FLOAT_LITERAL
%token <intVal> CHAR_LITERAL
%token <idName> ID
%token SEMI
%token ASSIGN
%token ARRAY_START     // [
%token ARRAY_END       // ]
%token PAREN_LEFT      // (
%token PAREN_RIGHT     // )
%token DEFINE_DEFAULT       // :
%type <expNode> exp
%type <statementNode> statement
%type <node> program
%left   PLUS MINUS
%left   MULT DIV
%right  UMINUS

//always define most specific first, least specific last in statements
%%
program: { program = new ProgramNode(yylineno); }
    | program statement { assert(program); program->addStatement($2); }
    ;

statement: 
      ID ARRAY_START exp ARRAY_END DEFINE_DEFAULT exp SEMI { $$ = new ArrayDefNode(yylineno, strdup($1), $3, $6); free($1); } 
    | ID ARRAY_START exp ARRAY_END ASSIGN exp SEMI 
      { 
          $$ = new ArrayAssignNode(yylineno, strdup($1), $3, $6); 
          free($1); 
      }
    | ID ASSIGN exp SEMI { $$ = new AssignmentNode(yylineno, strdup($1), $3); free($1); }
    | exp SEMI { $$ = new StatementNode(yylineno, $1); }
    ;

exp:
   INTEGER_LITERAL  { $$ = new IntegerNode(yylineno, $1); }
    | FLOAT_LITERAL { $$ = new FloatNode(yylineno, $1); }
    | CHAR_LITERAL { $$ = new CharNode(yylineno, $1); }
    | ID            { $$ = new IdentifierNode(yylineno, strdup($1)); free($1); }
    | PAREN_LEFT exp PAREN_RIGHT { $$ = $2; }
    | MINUS exp %prec UMINUS{ $$ = new UMinusNode(yylineno, $2); }
    | exp PLUS exp  { $$ = new PlusNode(yylineno, $1, $3); }
    | exp MINUS exp { $$ = new MinusNode(yylineno, $1, $3); }
    | exp MULT exp  { $$ = new MultNode(yylineno, $1, $3); }
    | exp DIV exp   { $$ = new DivNode(yylineno, $1, $3); }
    | ID ARRAY_START exp ARRAY_END { $$ = new ArrayAccessNode(yylineno, strdup($1), $3); free($1); }
    
    ;
